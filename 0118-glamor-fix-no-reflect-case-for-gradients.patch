From c715645c14ec00cd49e6bb86340351fa97ab6ea0 Mon Sep 17 00:00:00 2001
From: Jeff Smith <whydoubt@gmail.com>
Date: Fri, 26 Jan 2018 06:25:20 -0600
Subject: [PATCH 118/123] glamor: fix no-reflect case for gradients

When compositing a no-reflect gradient, 'before' the gradient is empty,
but 'after' the gradient is padded with the final color.  Both sides are
supposed to be empty.

This is fixed by moving the virtual stops to match the first and last
client-supplied stops for no-reflect gradients, then causing everything
'before' the initial virtual stop and 'after' the final virtual stop to
emit rgba(0,0,0,0).  This does not impact gradients using the other
reflect modes.

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
Reviewed-by: Adam Jackson <ajax@redhat.com>
(cherry picked from commit 5815c7b5951fd46d69e5c40144b64e516c7afdbf)
---
 glamor/glamor_gradient.c | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/glamor/glamor_gradient.c b/glamor/glamor_gradient.c
index 14ff917..e9880e7 100644
--- a/glamor/glamor_gradient.c
+++ b/glamor/glamor_gradient.c
@@ -57,10 +57,15 @@ _glamor_create_getcolor_fs_source(ScreenPtr screen, int stops_count,
 	    "    float new_alpha; \n"\
 	    "    vec4 gradient_color;\n"\
 	    "    float percentage; \n"\
-	    "    for(i = 0; i < n_stop - 1; i++) {\n"\
+	    "    \n"\
+	    "    if(stop_len < stops[0])\n"\
+	    "        return vec4(0.0, 0.0, 0.0, 0.0); \n"\
+	    "    for(i = 1; i < n_stop; i++) {\n"\
 	    "        if(stop_len < stops[i])\n"\
 	    "            break; \n"\
 	    "    }\n"\
+	    "    if(i == n_stop)\n"\
+	    "        return vec4(0.0, 0.0, 0.0, 0.0); \n"\
 	    "    \n"\
 	    "    if(stops[i] - stops[i-1] > 2.0)\n"\
 	    "        percentage = 0.0;\n" /*For comply with pixman, walker->stepper overflow.*/\
@@ -110,10 +115,10 @@ _glamor_create_getcolor_fs_source(ScreenPtr screen, int stops_count,
         "    float percentage; \n"
         "    \n"
         "    if((stop_len < stop0) && (n_stop >= 1)) {\n"
-        "        stop_color_before = stop_color0;\n"
-        "        stop_color_after = stop_color0;\n"
-        "        stop_after = stop0;\n"
-        "        stop_before = stop0;\n"
+        "        stop_color_before = vec4(0.0, 0.0, 0.0, 0.0);\n"
+        "        stop_color_after = vec4(0.0, 0.0, 0.0, 0.0);\n"
+        "        stop_after = 0.0;\n"
+        "        stop_before = 0.0;\n"
         "    } else if((stop_len < stop1) && (n_stop >= 2)) {\n"
         "        stop_color_before = stop_color0;\n"
         "        stop_color_after = stop_color1;\n"
@@ -150,10 +155,10 @@ _glamor_create_getcolor_fs_source(ScreenPtr screen, int stops_count,
         "        stop_after = stop7;\n"
         "        stop_before = stop6;\n"
         "    } else {\n"
-        "        stop_color_before = stop_color7;\n"
-        "        stop_color_after = stop_color7;\n"
-        "        stop_after = stop7;\n"
-        "        stop_before = stop7;\n"
+        "        stop_color_before = vec4(0.0, 0.0, 0.0, 0.0);\n"
+        "        stop_color_after = vec4(0.0, 0.0, 0.0, 0.0);\n"
+        "        stop_after = 0.0;\n"
+        "        stop_before = 0.0;\n"
         "    }\n"
         "    if(stop_after - stop_before > 2.0)\n"
         "        percentage = 0.0;\n" //For comply with pixman, walker->stepper overflow.
@@ -758,13 +763,13 @@ _glamor_gradient_set_stops(PicturePtr src_picture, PictGradient *pgradient,
         stop_colors[1] = 0.0;   //G
         stop_colors[2] = 0.0;   //B
         stop_colors[3] = 0.0;   //Alpha
-        n_stops[0] = -(float) INT_MAX;  //should be small enough.
+        n_stops[0] = n_stops[1];
 
         stop_colors[0 + (count - 1) * 4] = 0.0; //R
         stop_colors[1 + (count - 1) * 4] = 0.0; //G
         stop_colors[2 + (count - 1) * 4] = 0.0; //B
         stop_colors[3 + (count - 1) * 4] = 0.0; //Alpha
-        n_stops[count - 1] = (float) INT_MAX;   //should be large enough.
+        n_stops[count - 1] = n_stops[count - 2];
         break;
     case PIXMAN_REPEAT_NORMAL:
         REPEAT_FILL_STOPS(0, count - 2);
-- 
2.8.3

